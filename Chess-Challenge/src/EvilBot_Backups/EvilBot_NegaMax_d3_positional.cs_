using ChessChallenge.API;
using System.Collections.Generic;
using System;
using System.Linq;

namespace ChessChallenge.Example
{
    public class EvilBot : IChessBot
    {
        private int currentSearchDepth;
        private Move bestMove;
        private int[] pieceVals = { 100, 290, 310, 500, 900, 0 };
        private Timer gameTimer;

        public Move Think(Board board, Timer timer)
        {
            gameTimer = timer;

            Move[] moves = board.GetLegalMoves();

            int searchDepth = 3;
            bestMove = moves[0];

            for (int curDepth = 1; curDepth <= searchDepth; curDepth++)
            {
                currentSearchDepth = curDepth;
                int maxEval = NegaMax(board, curDepth, -10000000, 10000000);
                if (maxEval == 10000)
                {
                    break;
                }
                if ((double)gameTimer.MillisecondsElapsedThisTurn > (double)gameTimer.MillisecondsRemaining * 0.07)
                {
                    break;
                }
            }
            return bestMove;
        }

        public void orderMoves(Board board, Move[] moves)
        {
            int[] moveValList = new int[moves.Length];
            int index = 0;
            foreach (Move move in moves)
            {
                Piece movePieceType = board.GetPiece(move.StartSquare);
                Piece capturePieceType = board.GetPiece(move.TargetSquare);

                if (capturePieceType.PieceType != PieceType.None)
                {
                    moveValList[index] += getPieceVal(capturePieceType) - getPieceVal(movePieceType);
                }

                index++;
            }
            Array.Sort(moveValList, moves);
            Array.Reverse(moves);
        }

        public int NegaMax(Board board, int depth, int alpha, int beta)
        {

            Move[] legal_moves = board.GetLegalMoves();
            orderMoves(board, legal_moves);

            if (legal_moves.Length == 0)
            {
                if (board.IsInCheck())
                {
                    return -10000;
                }
                return 0;
            }

            if (depth == 0)
            {
                int evaluation = NegaMaxCapturesOnly(board, alpha, beta);
                return evaluation;
            }

            int maxEval = alpha;
            foreach (Move move in legal_moves)
            {
                board.MakeMove(move);
                int eval = -NegaMax(board, depth - 1, -beta, -maxEval);

                if ((double)gameTimer.MillisecondsElapsedThisTurn > (double)gameTimer.MillisecondsRemaining * 0.07)
                {
                    return beta;
                }

                if (board.GameRepetitionHistory.Contains(board.ZobristKey))
                {
                    board.UndoMove(move);
                    continue;
                }

                board.UndoMove(move);
                if (eval > maxEval)
                {
                    maxEval = eval;
                    if (depth == currentSearchDepth)
                    {
                        bestMove = move;
                    }
                    if (maxEval >= beta)
                    {
                        return beta;
                    }
                }
            }
            return maxEval;
        }

        public int NegaMaxCapturesOnly(Board board, int alpha, int beta)
        {
            int evaluation = Evaluate_NegaMax(board);
            if (evaluation >= beta)
            {
                return beta;
            }
            alpha = Math.Max(alpha, evaluation);

            Move[] legal_moves = board.GetLegalMoves(true);
            orderMoves(board, legal_moves);

            foreach (Move move in legal_moves)
            {
                board.MakeMove(move);
                int eval = -NegaMaxCapturesOnly(board, -beta, -alpha);
                board.UndoMove(move);

                if (eval >= beta)
                {
                    return beta;
                }
                alpha = Math.Max(alpha, eval);
            }
            return alpha;
        }

        public int Evaluate_NegaMax(Board board)
        {
            PieceList[] piecesLists = board.GetAllPieceLists();
            int eval = 0;
            int material_maxplayer = 0, material_minplayer = 0;
            for (int i = 0; i < piecesLists.Length / 2; i++)
            {
                material_maxplayer += piecesLists[i].Count * pieceVals[i];
                material_minplayer += piecesLists[i + 6].Count * pieceVals[i];
            }

            eval += KnightPositionEval(board);

            // Black-White differenciation until here

            if (!board.IsWhiteToMove)
            {
                eval = eval * -1;
            }

            // Max-Min Player differenciation beginning here

            if (!board.IsWhiteToMove)
            {
                int temp = material_maxplayer;
                material_maxplayer = material_minplayer;
                material_minplayer = temp;
            }
            eval += material_maxplayer - material_minplayer;

            if (material_maxplayer > material_minplayer && material_minplayer < 900)
            {
                eval += KingToEdgeEvalutation(board);
            }
            else if (material_minplayer > material_maxplayer && material_maxplayer < 900)
            {
                eval -= KingToEdgeEvalutation(board);
            }

            return eval;
        }

        public int getPieceVal(Piece piece)
        {
            return pieceVals[((int)piece.PieceType) - 1];
        }

        public int KingToEdgeEvalutation(Board board)
        {
            int manhattanDist = Math.Abs(board.GetKingSquare(true).Rank - board.GetKingSquare(false).Rank);
            manhattanDist += Math.Abs(board.GetKingSquare(true).File - board.GetKingSquare(false).File);
            int eval = (14 - manhattanDist) * 2;
            return (14 - manhattanDist) * 2;
        }

        public int KnightPositionEval(Board board)
        {
            double eval = 0;
            double paraboloid(double x, double y) => -Math.Pow(x - 3.5, 2) / 30 - Math.Pow(y - 3.5, 2) / 30 + 0.3;
            foreach (Piece knight in board.GetPieceList(PieceType.Knight, true))
            {
                eval += paraboloid(knight.Square.File, knight.Square.Rank);
            }
            foreach (Piece knight in board.GetPieceList(PieceType.Knight, false))
            {
                eval -= paraboloid(knight.Square.File, knight.Square.Rank);
            }
            return Convert.ToInt32(eval * 100);
        }
    }
}